Test 100: ❌ echo hi | >./outfiles/outfile01 echo bye >./test_files/invalid_permission 
Only in ./bash_outfiles: outfile01
mini outfiles:
cat: './mini_outfiles/*': No such file or directory
bash outfiles:
mini error = ( === TOKEN CLASSIFICATION START === Position 0, analyzing token 'echo' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) 'echo' -> CMD === TOKEN CLASSIFICATION END === extracting 'echo' from position 0-3 === TOKEN CLASSIFICATION START === Position 1, analyzing token 'echo' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) 'echo' -> CMD === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 0, creating token 'echo' as CMD Before creation - prev_type=CMD, curr_type=CMD Pipeline state - in_pipe=0 Updated prev_type to CMD for next classification === TOKEN CREATION END === extracting ' ' from position 4-4 === TOKEN CLASSIFICATION START === Position 2, analyzing token 'hi' Current state - prev_type=CMD, head=exists, in_pipe=0 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS false false 0 false Classified as ARGS (default) 'hi' -> ARGS === TOKEN CLASSIFICATION END === extracting 'hi' from position 5-6 === TOKEN CLASSIFICATION START === Position 3, analyzing token 'hi' Current state - prev_type=CMD, head=exists, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 0 false Classified as ARGS (default) 'hi' -> ARGS === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 1, creating token 'hi' as ARGS Before creation - prev_type=ARGS, curr_type=ARGS Pipeline state - in_pipe=0 Appending 'hi' to node type=CMD 1 'echo' Successfully created new args array with 2 elements 2) Updated prev_type to ARGS for next classification === TOKEN CREATION END === extracting ' ' from position 7-7 === TOKEN CREATION START === Position 2, creating token '|' as | Before creation - prev_type=ARGS, curr_type=| Pipeline state - in_pipe=0 Set in_pipe=1 for pipe token Updated prev_type to | for next classification === TOKEN CREATION END === extracting '|' from position 8-8 extracting ' ' from position 9-9 extracting '>./outfiles/outfile01' from position 10-30 extracting ' ' from position 31-31 === TOKEN CLASSIFICATION START === Position 4, analyzing token 'echo' Current state - prev_type=|, head=exists, in_pipe=1 Updated prev_type to > Analyzing regular token for CMD vs ARGS false false 1 true Classified as CMD (pipeline + after redirection) 'echo' -> CMD === TOKEN CLASSIFICATION END === extracting 'echo' from position 32-35 === TOKEN CLASSIFICATION START === Position 5, analyzing token 'echo' Current state - prev_type=>, head=exists, in_pipe=1 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS false false 1 false Classified as ARGS (default) 'echo' -> ARGS === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 3, creating token 'echo' as ARGS Before creation - prev_type=CMD, curr_type=ARGS Pipeline state - in_pipe=1 Updated prev_type to ARGS for next classification === TOKEN CREATION END === extracting ' ' from position 36-36 === TOKEN CLASSIFICATION START === Position 6, analyzing token 'bye' Current state - prev_type=ARGS, head=exists, in_pipe=1 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 1 false Classified as ARGS (default) 'bye' -> ARGS === TOKEN CLASSIFICATION END === extracting 'bye' from position 37-39 === TOKEN CLASSIFICATION START === Position 7, analyzing token 'bye' Current state - prev_type=ARGS, head=exists, in_pipe=1 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 1 false Classified as ARGS (default) 'bye' -> ARGS === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 4, creating token 'bye' as ARGS Before creation - prev_type=ARGS, curr_type=ARGS Pipeline state - in_pipe=1 Updated prev_type to ARGS for next classification === TOKEN CREATION END === extracting ' ' from position 40-40 extracting '>./test_files/invalid_permission' from position 41-72 Adding null token safety stop Null token added at the end of list Resetting redirection tracking state Building redirection AST (command-first approach) Checking redirection node type=> Valid redirection node > with embedded filename './outfiles/outfile01' Checking redirection node type=> Valid redirection node > with embedded filename './test_files/invalid_permission' Processing command 'echo' Starting to link redirections for command 'echo' No redirections found for cmd 'echo' Starting argument verification Processing node type=CMD, args[0]='echo' Found command 'echo' Processing node type=|, args[0]='|' Found pipe, resetting command context Processing node type=>, args[0]='./outfiles/outfile01' Found redirection, continuing with same command context Processing node type=ARGS, args[0]='echo' Processing node type=ARGS, args[0]='bye' Processing node type=>, args[0]='./test_files/invalid_permission' Found redirection, continuing with same command context Processing node type=ARGS, args[0]='' Argument verification completed Starting redirection execution for node type=> Missing left node, returning error)
bash error = ( Permission denied)

Test 131: ❌ cat <minishell.h|ls 
mini output = ()
bash output = (ast.txt bash_outfiles bash.supp bonus bonus_bonus builtins extras local.supp loop.out manual_tests mini_outfiles minishell os_specific outfiles pipes README.md redirects syntax temp tester test_files tokens.txt wildcards)
mini error = ( === TOKEN CLASSIFICATION START === Position 0, analyzing token 'cat' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) 'cat' -> CMD === TOKEN CLASSIFICATION END === extracting 'cat' from position 0-2 === TOKEN CLASSIFICATION START === Position 1, analyzing token 'cat' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) 'cat' -> CMD === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 0, creating token 'cat' as CMD Before creation - prev_type=CMD, curr_type=CMD Pipeline state - in_pipe=0 Updated prev_type to CMD for next classification === TOKEN CREATION END === extracting ' ' from position 3-3 extracting '<minishell.h' from position 4-15 === TOKEN CREATION START === Position 1, creating token '|' as | Before creation - prev_type=CMD, curr_type=| Pipeline state - in_pipe=0 Set in_pipe=1 for pipe token Updated prev_type to | for next classification === TOKEN CREATION END === extracting '|' from position 16-16 Adding null token safety stop Null token added at the end of list === TOKEN CLASSIFICATION START === Position 2, analyzing token 'ls' Current state - prev_type=|, head=exists, in_pipe=1 Updated prev_type to | Analyzing regular token for CMD vs ARGS false true 1 false Classified as CMD (head or after pipe) 'ls' -> CMD === TOKEN CLASSIFICATION END === extracting 'ls' from position 17-18 === TOKEN CLASSIFICATION START === Position 3, analyzing token 'ls' Current state - prev_type=|, head=exists, in_pipe=1 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS false false 1 false Classified as ARGS (default) 'ls' -> ARGS === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 2, creating token 'ls' as ARGS Before creation - prev_type=CMD, curr_type=ARGS Pipeline state - in_pipe=1 Updated prev_type to ARGS for next classification === TOKEN CREATION END === Resetting redirection tracking state Building redirection AST (command-first approach) Checking redirection node type=< Valid redirection node < with embedded filename 'minishell.h' Processing command 'cat' Starting to link redirections for command 'cat' Found redirection < 'minishell.h' for command 'cat' Set first redirection for command 'cat' < 'minishell.h' -> END Starting argument verification Processing node type=CMD, args[0]='cat' Found command 'cat' Processing node type=<, args[0]='minishell.h' Found redirection, continuing with same command context Processing node type=|, args[0]='|' Found pipe, resetting command context Processing node type=ARGS, args[0]='' Processing node type=ARGS, args[0]='ls' Argument verification completed Starting redirection execution for node type=< 'cat' (pipeline_context=1) Saved stdin=3, stdout=4 About to process redirection chain Starting redirection chain processing < 'minishell.h' 'cat' Processing redirection < 'minishell.h' 'minishell.h' 'minishell.h' Checking access to file 'minishell.h' File 'minishell.h' does not exist No such file or directory Handling missing input file (pipeline_context=0) Non-pipeline context - failing execution Redirection failed for 'minishell.h' Redirection failed, cleaning up and returning error_code=1 NOT executing command due to redirection failure Pipeline context - exiting with 0 for input redirection error)
bash error = ( No such file or directory)
 
Test 133: ❌ $PWD 
mini exit code = 2
bash exit code = 126
mini error = ( extracting '$PWD' from position 0-3 Adding null token safety stop Null token added at the end of list Resetting redirection tracking state Building redirection AST (command-first approach) Processing command '/home/bleow/Coding/Core/minishell/minishell_tester' Starting to link redirections for command '/home/bleow/Coding/Core/minishell/minishell_tester' No redirections found for cmd '/home/bleow/Coding/Core/minishell/minishell_tester' Starting argument verification Processing node type=CMD, args[0]='/home/bleow/Coding/Core/minishell/minishell_tester' Found command '/home/bleow/Coding/Core/minishell/minishell_tester' Processing node type=ARGS, args[0]='' Argument verification completed Is a directory)
bash error = ( Is a directory)
Test 134: ❌ $EMPTY 
mini exit code = 127
bash exit code = 0
mini error = ( extracting '$EMPTY' from position 0-5 Adding null token safety stop Null token added at the end of list Resetting redirection tracking state Building redirection AST (command-first approach) Processing command '' Starting to link redirections for command '' No redirections found for cmd '' Starting argument verification Processing node type=CMD, args[0]='' Found command '' Processing node type=ARGS, args[0]='' Argument verification completed Permission denied)
bash error = ()
Test 135: ❌ $EMPTY echo hi 
mini output = ()
bash output = (hi)
mini exit code = 127
bash exit code = 0
mini error = ( extracting '$EMPTY' from position 0-5 extracting ' ' from position 6-6 === TOKEN CLASSIFICATION START === Position 0, analyzing token 'echo' Current state - prev_type=ARGS, head=exists, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 0 false Classified as ARGS (default) 'echo' -> ARGS === TOKEN CLASSIFICATION END === extracting 'echo' from position 7-10 === TOKEN CLASSIFICATION START === Position 1, analyzing token 'echo' Current state - prev_type=ARGS, head=exists, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 0 false Classified as ARGS (default) 'echo' -> ARGS === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 0, creating token 'echo' as ARGS Before creation - prev_type=ARGS, curr_type=ARGS Pipeline state - in_pipe=0 Appending 'echo' to node type=CMD 1 '' Successfully created new args array with 2 elements 2) Updated prev_type to ARGS for next classification === TOKEN CREATION END === extracting ' ' from position 11-11 Adding null token safety stop Null token added at the end of list === TOKEN CLASSIFICATION START === Position 2, analyzing token 'hi' Current state - prev_type=ARGS, head=exists, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 0 false Classified as ARGS (default) 'hi' -> ARGS === TOKEN CLASSIFICATION END === extracting 'hi' from position 12-13 === TOKEN CLASSIFICATION START === Position 3, analyzing token 'hi' Current state - prev_type=ARGS, head=exists, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS false false 0 false Classified as ARGS (default) 'hi' -> ARGS === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 1, creating token 'hi' as ARGS Before creation - prev_type=ARGS, curr_type=ARGS Pipeline state - in_pipe=0 Updated prev_type to ARGS for next classification === TOKEN CREATION END === Resetting redirection tracking state Building redirection AST (command-first approach) Processing command '' Starting to link redirections for command '' No redirections found for cmd '' Starting argument verification Processing node type=CMD, args[0]='' Found command '' Processing node type=ARGS, args[0]='' Processing node type=ARGS, args[0]='hi' Checking if node 'hi' is redirection target Node 'hi' is NOT a redirection target Found orphaned argument 'hi' for command '' Appending 'hi' to node type=CMD 2 '' 'echo' Successfully created new args array with 3 elements 3) Appended argument 'hi' to command '' Argument verification completed Permission denied)
bash error = ()
Test 136: ❌ ./test_files/invalid_permission 
mini exit code = 127
bash exit code = 126
mini error = ( Adding null token safety stop === TOKEN CLASSIFICATION START === Position 0, analyzing token './test_files/invalid_permission' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) './test_files/invalid_permission' -> CMD === TOKEN CLASSIFICATION END === extracting './test_files/invalid_permission' from position 0-30 === TOKEN CLASSIFICATION START === Position 1, analyzing token './test_files/invalid_permission' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) './test_files/invalid_permission' -> CMD === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 0, creating token './test_files/invalid_permission' as CMD Before creation - prev_type=CMD, curr_type=CMD Pipeline state - in_pipe=0 Updated prev_type to CMD for next classification === TOKEN CREATION END === Resetting redirection tracking state Building redirection AST (command-first approach) Processing command './test_files/invalid_permission' Starting to link redirections for command './test_files/invalid_permission' No redirections found for cmd './test_files/invalid_permission' Starting argument verification Processing node type=CMD, args[0]='./test_files/invalid_permission' Found command './test_files/invalid_permission' Argument verification completed Permission denied)
bash error = ( Permission denied)

Test 141: ❌ ./test_files 
mini exit code = 2
bash exit code = 126
mini error = ( Adding null token safety stop === TOKEN CLASSIFICATION START === Position 0, analyzing token './test_files' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to ARGS Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) './test_files' -> CMD === TOKEN CLASSIFICATION END === extracting './test_files' from position 0-11 === TOKEN CLASSIFICATION START === Position 1, analyzing token './test_files' Current state - prev_type=ARGS, head=NULL, in_pipe=0 Updated prev_type to CMD Analyzing regular token for CMD vs ARGS true false 0 false Classified as CMD (head or after pipe) './test_files' -> CMD === TOKEN CLASSIFICATION END === === TOKEN CREATION START === Position 0, creating token './test_files' as CMD Before creation - prev_type=CMD, curr_type=CMD Pipeline state - in_pipe=0 Updated prev_type to CMD for next classification === TOKEN CREATION END === Resetting redirection tracking state Building redirection AST (command-first approach) Processing command './test_files' Starting to link redirections for command './test_files' No redirections found for cmd './test_files' Starting argument verification Processing node type=CMD, args[0]='./test_files' Found command './test_files' Argument verification completed Is a directory)
bash error = ( Is a directory)

139/146

