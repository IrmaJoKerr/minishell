bleshell$> cat << END  
This is a test: $HOME
END
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 2, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 3, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 1, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 2, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 0)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: ON
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 3, creating token 'END' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting 'END' from position 7-9
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
DEBUG-HD-COMPARE: Comparing line 'This is a test: $HOME' with delimiter 'END'
DEBUG-HEREDOC: Content (27 bytes):
This is a test: /home/bleow
DEBUG-HD-COMPARE: Comparing line 'END' with delimiter 'END'
DEBUG-HD-COMPARE: Match found, ending heredoc
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 4, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 5, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 4, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 5, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 0)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: ON
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 6, creating token 'END' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting 'END' from position 7-9
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
= TOKEN LIST =
[0] CMD [cat]
[1] << [<<]
[2] ARGS [END]
[3] ARGS []

DEBUG-LIST: = LINKED LIST =
DEBUG-LIST: [0] DEBUG-NODE[LIST@linked_list]: Type=CMD, Args=['cat'], Connections: left=(nil), right=(nil), redir=(nil), prev=(nil), next=0x5acccd9e3d90
DEBUG-LIST: [1] DEBUG-NODE[LIST@linked_list]: Type=<<, Args=['<<'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3de0, next=0x5acccd9e3d40
DEBUG-LIST: [2] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=['END'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d90, next=0x5acccd9c7940
DEBUG-LIST: [3] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d40, next=(nil)
DEBUG-LIST: = END LINKED LIST (4 nodes) =
REDIR-DBG: Resetting redirection tracking state
DEBUG-FIX-REDIR: Starting to link redirections for command 'cat'
DEBUG-FIX-REDIR: Found redirection << '<<' for command 'cat'
DEBUG-FIX-REDIR: Set first redirection for command 'cat'
DEBUG-FIX-REDIR: Final redirection chain for cmd 'cat':
  0: << '<<' -> END
DEBUG-VALIDATE-REDIR: Checking redirection node type=<<
DEBUG-VALIDATE-REDIR: Valid redirection node << with embedded filename '<<'
DEBUG-MATCH-CMD: Starting command-argument matching
DEBUG-MATCH-CMD: Found command node 'cat'
DEBUG-MATCH-CMD: Checking if 'END' should be appended to 'cat'
DEBUG-IS-REDIR-TARGET: Checking node 'END', prev=<<
DEBUG-IS-REDIR-TARGET: Found redirection '<<' type=<<
DEBUG-HEREDOC-TARGET: Found heredoc, next=0x5acccd9e3d40, node=0x5acccd9e3d40
DEBUG-HEREDOC-TARGET: Node directly follows heredoc operator
DEBUG-HEREDOC-TARGET: Node IS a heredoc delimiter target
DEBUG-MATCH-CMD: Decision: SKIP
DEBUG-MATCH-CMD: Skipping 'END' (redirection target)
DEBUG-MATCH-CMD: Finished command-argument matching
=== ABSTRACT SYNTAX TREE ===
<< [<<]
├─(redir)-> CMD [cat]
├─(redir)->  [CYCLE DETECTED]
├─(left)->   CMD [cat]
  ├─(redir)->  [CYCLE DETECTED]
DEBUG-AST: = DETAILED AST =
DEBUG-AST: Node(0x5acccd9e3d90): Type=<<, Args=['<<'], Connections: { left->0x5acccd9e3de0 redir->0x5acccd9e3de0 prev->0x5acccd9e3de0 next->0x5acccd9e3d40 }
DEBUG-AST: Node(0x5acccd9e3de0): Type=CMD, Args=['cat'], Connections: { redir->0x5acccd9e3d90 next->0x5acccd9e3d90 }
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3de0)
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3d90)
DEBUG-EXEC-REDIR: Starting redirection execution for node type=<<
DEBUG-EXEC-REDIR: Found command node: 'cat' (pipeline_context=0)
DEBUG-EXEC-REDIR: Saved stdin=3, stdout=4
DEBUG-EXEC-REDIR: About to process redirection chain
DEBUG-FIX-CHAIN: Starting redirection chain processing
DEBUG-FIX-CHAIN: Start node: << '<<'
DEBUG-FIX-CHAIN: Command: 'cat'
DEBUG-FIX-CHAIN: Processing redirection << '<<'
DEBUG-FIX-CHAIN: Before stripping quotes: '<<'
DEBUG-FIX-CHAIN: After stripping quotes: '<<'
DEBUG-FIX-CHAIN: Moving to next redirection: END
DEBUG-FIX-CHAIN: Chain processing completed successfully
DEBUG-EXEC-REDIR: Redirection successful, executing command 'cat'
This is a test: /home/bleow
DEBUG-EXEC-REDIR: Command execution completed with result=0
bleshell$> cat << 'END'
This is a test: $HOME
END
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 6, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 3: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 7, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 7, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 8, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 1)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: OFF
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 9, creating token ''END'' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting ''END'' from position 7-11
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
DEBUG-HD-COMPARE: Comparing line 'This is a test: $HOME' with delimiter 'END'
DEBUG-HEREDOC: Content (21 bytes):
This is a test: $HOME
DEBUG-HD-COMPARE: Comparing line 'END' with delimiter 'END'
DEBUG-HD-COMPARE: Match found, ending heredoc
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 8, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 4: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 9, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 10, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 11, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 1)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: OFF
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 12, creating token ''END'' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting ''END'' from position 7-11
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
= TOKEN LIST =
[0] CMD [cat]
[1] << [<<]
[2] ARGS ['END']
[3] ARGS []

DEBUG-LIST: = LINKED LIST =
DEBUG-LIST: [0] DEBUG-NODE[LIST@linked_list]: Type=CMD, Args=['cat'], Connections: left=(nil), right=(nil), redir=(nil), prev=(nil), next=0x5acccd9e3d90
DEBUG-LIST: [1] DEBUG-NODE[LIST@linked_list]: Type=<<, Args=['<<'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3de0, next=0x5acccd9e3d40
DEBUG-LIST: [2] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''END''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d90, next=0x5acccd9c7940
DEBUG-LIST: [3] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d40, next=(nil)
DEBUG-LIST: = END LINKED LIST (4 nodes) =
REDIR-DBG: Resetting redirection tracking state
DEBUG-FIX-REDIR: Starting to link redirections for command 'cat'
DEBUG-FIX-REDIR: Found redirection << '<<' for command 'cat'
DEBUG-FIX-REDIR: Set first redirection for command 'cat'
DEBUG-FIX-REDIR: Final redirection chain for cmd 'cat':
  0: << '<<' -> END
DEBUG-VALIDATE-REDIR: Checking redirection node type=<<
DEBUG-VALIDATE-REDIR: Valid redirection node << with embedded filename '<<'
DEBUG-MATCH-CMD: Starting command-argument matching
DEBUG-MATCH-CMD: Found command node 'cat'
DEBUG-MATCH-CMD: Checking if ''END'' should be appended to 'cat'
DEBUG-IS-REDIR-TARGET: Checking node ''END'', prev=<<
DEBUG-IS-REDIR-TARGET: Found redirection '<<' type=<<
DEBUG-HEREDOC-TARGET: Found heredoc, next=0x5acccd9e3d40, node=0x5acccd9e3d40
DEBUG-HEREDOC-TARGET: Node directly follows heredoc operator
DEBUG-HEREDOC-TARGET: Node IS a heredoc delimiter target
DEBUG-MATCH-CMD: Decision: SKIP
DEBUG-MATCH-CMD: Skipping ''END'' (redirection target)
DEBUG-MATCH-CMD: Finished command-argument matching
=== ABSTRACT SYNTAX TREE ===
<< [<<]
├─(redir)-> CMD [cat]
├─(redir)->  [CYCLE DETECTED]
├─(left)->   CMD [cat]
  ├─(redir)->  [CYCLE DETECTED]
DEBUG-AST: = DETAILED AST =
DEBUG-AST: Node(0x5acccd9e3d90): Type=<<, Args=['<<'], Connections: { left->0x5acccd9e3de0 redir->0x5acccd9e3de0 prev->0x5acccd9e3de0 next->0x5acccd9e3d40 }
DEBUG-AST: Node(0x5acccd9e3de0): Type=CMD, Args=['cat'], Connections: { redir->0x5acccd9e3d90 next->0x5acccd9e3d90 }
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3de0)
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3d90)
DEBUG-EXEC-REDIR: Starting redirection execution for node type=<<
DEBUG-EXEC-REDIR: Found command node: 'cat' (pipeline_context=0)
DEBUG-EXEC-REDIR: Saved stdin=3, stdout=4
DEBUG-EXEC-REDIR: About to process redirection chain
DEBUG-FIX-CHAIN: Starting redirection chain processing
DEBUG-FIX-CHAIN: Start node: << '<<'
DEBUG-FIX-CHAIN: Command: 'cat'
DEBUG-FIX-CHAIN: Processing redirection << '<<'
DEBUG-FIX-CHAIN: Before stripping quotes: '<<'
DEBUG-FIX-CHAIN: After stripping quotes: '<<'
DEBUG-FIX-CHAIN: Moving to next redirection: END
DEBUG-FIX-CHAIN: Chain processing completed successfully
DEBUG-EXEC-REDIR: Redirection successful, executing command 'cat'
This is a test: $HOME
DEBUG-EXEC-REDIR: Command execution completed with result=0
bleshell$> cat << "END"
This is a test: $HOME
END
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 10, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 5: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 11, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 13, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 14, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 1)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: OFF
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 15, creating token '"END"' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting '"END"' from position 7-11
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
DEBUG-HD-COMPARE: Comparing line 'This is a test: $HOME' with delimiter 'END'
DEBUG-HEREDOC: Content (21 bytes):
This is a test: $HOME
DEBUG-HD-COMPARE: Comparing line 'END' with delimiter 'END'
DEBUG-HD-COMPARE: Match found, ending heredoc
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 12, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 6: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 13, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 16, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 17, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 1)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: OFF
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 18, creating token '"END"' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting '"END"' from position 7-11
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
= TOKEN LIST =
[0] CMD [cat]
[1] << [<<]
[2] ARGS ["END"]
[3] ARGS []

DEBUG-LIST: = LINKED LIST =
DEBUG-LIST: [0] DEBUG-NODE[LIST@linked_list]: Type=CMD, Args=['cat'], Connections: left=(nil), right=(nil), redir=(nil), prev=(nil), next=0x5acccd9e3d90
DEBUG-LIST: [1] DEBUG-NODE[LIST@linked_list]: Type=<<, Args=['<<'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3de0, next=0x5acccd9e3d40
DEBUG-LIST: [2] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=['"END"'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d90, next=0x5acccd9c7940
DEBUG-LIST: [3] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d40, next=(nil)
DEBUG-LIST: = END LINKED LIST (4 nodes) =
REDIR-DBG: Resetting redirection tracking state
DEBUG-FIX-REDIR: Starting to link redirections for command 'cat'
DEBUG-FIX-REDIR: Found redirection << '<<' for command 'cat'
DEBUG-FIX-REDIR: Set first redirection for command 'cat'
DEBUG-FIX-REDIR: Final redirection chain for cmd 'cat':
  0: << '<<' -> END
DEBUG-VALIDATE-REDIR: Checking redirection node type=<<
DEBUG-VALIDATE-REDIR: Valid redirection node << with embedded filename '<<'
DEBUG-MATCH-CMD: Starting command-argument matching
DEBUG-MATCH-CMD: Found command node 'cat'
DEBUG-MATCH-CMD: Checking if '"END"' should be appended to 'cat'
DEBUG-IS-REDIR-TARGET: Checking node '"END"', prev=<<
DEBUG-IS-REDIR-TARGET: Found redirection '<<' type=<<
DEBUG-HEREDOC-TARGET: Found heredoc, next=0x5acccd9e3d40, node=0x5acccd9e3d40
DEBUG-HEREDOC-TARGET: Node directly follows heredoc operator
DEBUG-HEREDOC-TARGET: Node IS a heredoc delimiter target
DEBUG-MATCH-CMD: Decision: SKIP
DEBUG-MATCH-CMD: Skipping '"END"' (redirection target)
DEBUG-MATCH-CMD: Finished command-argument matching
=== ABSTRACT SYNTAX TREE ===
<< [<<]
├─(redir)-> CMD [cat]
├─(redir)->  [CYCLE DETECTED]
├─(left)->   CMD [cat]
  ├─(redir)->  [CYCLE DETECTED]
DEBUG-AST: = DETAILED AST =
DEBUG-AST: Node(0x5acccd9e3d90): Type=<<, Args=['<<'], Connections: { left->0x5acccd9e3de0 redir->0x5acccd9e3de0 prev->0x5acccd9e3de0 next->0x5acccd9e3d40 }
DEBUG-AST: Node(0x5acccd9e3de0): Type=CMD, Args=['cat'], Connections: { redir->0x5acccd9e3d90 next->0x5acccd9e3d90 }
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3de0)
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3d90)
DEBUG-EXEC-REDIR: Starting redirection execution for node type=<<
DEBUG-EXEC-REDIR: Found command node: 'cat' (pipeline_context=0)
DEBUG-EXEC-REDIR: Saved stdin=3, stdout=4
DEBUG-EXEC-REDIR: About to process redirection chain
DEBUG-FIX-CHAIN: Starting redirection chain processing
DEBUG-FIX-CHAIN: Start node: << '<<'
DEBUG-FIX-CHAIN: Command: 'cat'
DEBUG-FIX-CHAIN: Processing redirection << '<<'
DEBUG-FIX-CHAIN: Before stripping quotes: '<<'
DEBUG-FIX-CHAIN: After stripping quotes: '<<'
DEBUG-FIX-CHAIN: Moving to next redirection: END
DEBUG-FIX-CHAIN: Chain processing completed successfully
DEBUG-EXEC-REDIR: Redirection successful, executing command 'cat'
This is a test: $HOME
DEBUG-EXEC-REDIR: Command execution completed with result=0
bleshell$> cat << '"END"'
This is a test: $HOME
END
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 14, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 7: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 15, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 19, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 20, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter '"END"' (quoted: 1)
DEBUG-HEREDOC-DELIM: New delimiter set to '"END"', expansion: OFF
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 22 45 4e 44 22 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 21, creating token ''"END"'' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting ''"END"'' from position 7-13
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
DEBUG-HD-COMPARE: Comparing line 'This is a test: $HOME' with delimiter '"END"'
DEBUG-HEREDOC: Content (21 bytes):
This is a test: $HOME
DEBUG-HD-COMPARE: Comparing line 'END' with delimiter '"END"'
DEBUG-HEREDOC: Content (3 bytes):
END
heredoc> 'END'
DEBUG-HEREDOC: Content (5 bytes):
'END'
DEBUG-HEREDOC: Content (5 bytes):
'END'
heredoc> "END"
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 16, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 8: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 17, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 22, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 23, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter '"END"' (quoted: 1)
DEBUG-HEREDOC-DELIM: New delimiter set to '"END"', expansion: OFF
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 22 45 4e 44 22 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 24, creating token ''"END"'' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting ''"END"'' from position 7-13
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
= TOKEN LIST =
[0] CMD [cat]
[1] << [<<]
[2] ARGS ['"END"']
[3] ARGS []

DEBUG-LIST: = LINKED LIST =
DEBUG-LIST: [0] DEBUG-NODE[LIST@linked_list]: Type=CMD, Args=['cat'], Connections: left=(nil), right=(nil), redir=(nil), prev=(nil), next=0x5acccd9e3d90
DEBUG-LIST: [1] DEBUG-NODE[LIST@linked_list]: Type=<<, Args=['<<'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3de0, next=0x5acccd9e3d40
DEBUG-LIST: [2] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''"END"''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d90, next=0x5acccd9c7940
DEBUG-LIST: [3] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d40, next=(nil)
DEBUG-LIST: = END LINKED LIST (4 nodes) =
REDIR-DBG: Resetting redirection tracking state
DEBUG-FIX-REDIR: Starting to link redirections for command 'cat'
DEBUG-FIX-REDIR: Found redirection << '<<' for command 'cat'
DEBUG-FIX-REDIR: Set first redirection for command 'cat'
DEBUG-FIX-REDIR: Final redirection chain for cmd 'cat':
  0: << '<<' -> END
DEBUG-VALIDATE-REDIR: Checking redirection node type=<<
DEBUG-VALIDATE-REDIR: Valid redirection node << with embedded filename '<<'
DEBUG-MATCH-CMD: Starting command-argument matching
DEBUG-MATCH-CMD: Found command node 'cat'
DEBUG-MATCH-CMD: Checking if ''"END"'' should be appended to 'cat'
DEBUG-IS-REDIR-TARGET: Checking node ''"END"'', prev=<<
DEBUG-IS-REDIR-TARGET: Found redirection '<<' type=<<
DEBUG-HEREDOC-TARGET: Found heredoc, next=0x5acccd9e3d40, node=0x5acccd9e3d40
DEBUG-HEREDOC-TARGET: Node directly follows heredoc operator
DEBUG-HEREDOC-TARGET: Node IS a heredoc delimiter target
DEBUG-MATCH-CMD: Decision: SKIP
DEBUG-MATCH-CMD: Skipping ''"END"'' (redirection target)
DEBUG-MATCH-CMD: Finished command-argument matching
=== ABSTRACT SYNTAX TREE ===
<< [<<]
├─(redir)-> CMD [cat]
├─(redir)->  [CYCLE DETECTED]
├─(left)->   CMD [cat]
  ├─(redir)->  [CYCLE DETECTED]
DEBUG-AST: = DETAILED AST =
DEBUG-AST: Node(0x5acccd9e3d90): Type=<<, Args=['<<'], Connections: { left->0x5acccd9e3de0 redir->0x5acccd9e3de0 prev->0x5acccd9e3de0 next->0x5acccd9e3d40 }
DEBUG-AST: Node(0x5acccd9e3de0): Type=CMD, Args=['cat'], Connections: { redir->0x5acccd9e3d90 next->0x5acccd9e3d90 }
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3de0)
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3d90)
DEBUG-EXEC-REDIR: Starting redirection execution for node type=<<
DEBUG-EXEC-REDIR: Found command node: 'cat' (pipeline_context=0)
DEBUG-EXEC-REDIR: Saved stdin=3, stdout=4
DEBUG-EXEC-REDIR: About to process redirection chain
DEBUG-FIX-CHAIN: Starting redirection chain processing
DEBUG-FIX-CHAIN: Start node: << '<<'
DEBUG-FIX-CHAIN: Command: 'cat'
DEBUG-FIX-CHAIN: Processing redirection << '<<'
DEBUG-FIX-CHAIN: Before stripping quotes: '<<'
DEBUG-FIX-CHAIN: After stripping quotes: '<<'
DEBUG-FIX-CHAIN: Moving to next redirection: END
DEBUG-FIX-CHAIN: Chain processing completed successfully
DEBUG-EXEC-REDIR: Redirection successful, executing command 'cat'
This is a test: $HOME
END
'END'
DEBUG-EXEC-REDIR: Command execution completed with result=0
bleshell$> cat << END
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 18, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 9: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 19, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 25, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 26, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 0)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: ON
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 27, creating token 'END' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting 'END' from position 7-9
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
= TOKEN LIST =
[0] CMD [cat]
[1] << [<<]
[2] ARGS [END]
[3] ARGS []

DEBUG-LIST: = LINKED LIST =
DEBUG-LIST: [0] DEBUG-NODE[LIST@linked_list]: Type=CMD, Args=['cat'], Connections: left=(nil), right=(nil), redir=(nil), prev=(nil), next=0x5acccd9e3d40
DEBUG-LIST: [1] DEBUG-NODE[LIST@linked_list]: Type=<<, Args=['<<'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9c7940, next=0x5acccd9e3d90
DEBUG-LIST: [2] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=['END'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d40, next=0x5acccd9e3de0
DEBUG-LIST: [3] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d90, next=(nil)
DEBUG-LIST: = END LINKED LIST (4 nodes) =
REDIR-DBG: Resetting redirection tracking state
DEBUG-FIX-REDIR: Starting to link redirections for command 'cat'
DEBUG-FIX-REDIR: Found redirection << '<<' for command 'cat'
DEBUG-FIX-REDIR: Set first redirection for command 'cat'
DEBUG-FIX-REDIR: Final redirection chain for cmd 'cat':
  0: << '<<' -> END
DEBUG-VALIDATE-REDIR: Checking redirection node type=<<
DEBUG-VALIDATE-REDIR: Valid redirection node << with embedded filename '<<'
DEBUG-MATCH-CMD: Starting command-argument matching
DEBUG-MATCH-CMD: Found command node 'cat'
DEBUG-MATCH-CMD: Checking if 'END' should be appended to 'cat'
DEBUG-IS-REDIR-TARGET: Checking node 'END', prev=<<
DEBUG-IS-REDIR-TARGET: Found redirection '<<' type=<<
DEBUG-HEREDOC-TARGET: Found heredoc, next=0x5acccd9e3d90, node=0x5acccd9e3d90
DEBUG-HEREDOC-TARGET: Node directly follows heredoc operator
DEBUG-HEREDOC-TARGET: Node IS a heredoc delimiter target
DEBUG-MATCH-CMD: Decision: SKIP
DEBUG-MATCH-CMD: Skipping 'END' (redirection target)
DEBUG-MATCH-CMD: Finished command-argument matching
=== ABSTRACT SYNTAX TREE ===
<< [<<]
├─(redir)-> CMD [cat]
├─(redir)->  [CYCLE DETECTED]
├─(left)->   CMD [cat]
  ├─(redir)->  [CYCLE DETECTED]
DEBUG-AST: = DETAILED AST =
DEBUG-AST: Node(0x5acccd9e3d40): Type=<<, Args=['<<'], Connections: { left->0x5acccd9c7940 redir->0x5acccd9c7940 prev->0x5acccd9c7940 next->0x5acccd9e3d90 }
DEBUG-AST: Node(0x5acccd9c7940): Type=CMD, Args=['cat'], Connections: { redir->0x5acccd9e3d40 next->0x5acccd9e3d40 }
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9c7940)
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3d40)
DEBUG-EXEC-REDIR: Starting redirection execution for node type=<<
DEBUG-EXEC-REDIR: Found command node: 'cat' (pipeline_context=0)
DEBUG-EXEC-REDIR: Saved stdin=3, stdout=4
DEBUG-EXEC-REDIR: About to process redirection chain
DEBUG-FIX-CHAIN: Starting redirection chain processing
DEBUG-FIX-CHAIN: Start node: << '<<'
DEBUG-FIX-CHAIN: Command: 'cat'
DEBUG-FIX-CHAIN: Processing redirection << '<<'
DEBUG-FIX-CHAIN: Before stripping quotes: '<<'
DEBUG-FIX-CHAIN: After stripping quotes: '<<'
heredoc> test
DEBUG-HEREDOC: Content (4 bytes):
test
DEBUG-HEREDOC: Content (4 bytes):
test
heredoc> $HOME
DEBUG-HEREDOC: Content (5 bytes):
$HOME
DEBUG-HEREDOC: Content (11 bytes):
/home/bleow
heredoc> END
DEBUG-FIX-CHAIN: Moving to next redirection: END
DEBUG-FIX-CHAIN: Chain processing completed successfully
DEBUG-EXEC-REDIR: Redirection successful, executing command 'cat'
test
/home/bleow
DEBUG-EXEC-REDIR: Command execution completed with result=0
bleshell$> cat << END
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 20, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-TOKENIZE-LOOP: Token 10: extracting 'cat' from position 0-2
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION START ===
DEBUG-SET-TOKEN-TYPE: Position 21, analyzing token 'cat'
DEBUG-SET-TOKEN-TYPE: Current state - prev_type=ARGS, head=NULL, in_pipe=0
DEBUG-SET-TOKEN-TYPE: Keeping prev_type as ARGS (not updating yet)
DEBUG-SET-TOKEN-TYPE: Analyzing regular token for CMD vs ARGS
DEBUG-SET-TOKEN-TYPE: Conditions check:
  - !vars->head: true
  - prev_type == TYPE_PIPE: false
  - in_pipe: 0
  - is_redirection(prev_type): false
DEBUG-SET-TOKEN-TYPE: Classified as CMD (head or after pipe)
DEBUG-SET-TOKEN-TYPE: Final classification: 'cat' -> CMD
DEBUG-SET-TOKEN-TYPE: prev_type remains: ARGS (will be updated in maketoken)
DEBUG-SET-TOKEN-TYPE: === TOKEN CLASSIFICATION END ===

DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 28, creating token 'cat' as CMD
DEBUG-MAKETOKEN: Before creation - prev_type=ARGS, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from ARGS to CMD
DEBUG-MAKETOKEN: prev_type now set to CMD for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 0: extracting ' ' from position 3-3
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 29, creating token '<<' as <<
DEBUG-MAKETOKEN: Before creation - prev_type=CMD, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from CMD to <<
DEBUG-MAKETOKEN: prev_type now set to << for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 1: extracting '<<' from position 4-5
DEBUG-HEREDOC-DELIM: Storing delimiter 'END' (quoted: 0)
DEBUG-HEREDOC-DELIM: New delimiter set to 'END', expansion: ON
DEBUG-HEREDOC-DELIM: Hex dump of delimiter: 45 4e 44 
DEBUG-MAKETOKEN: === TOKEN CREATION START ===
DEBUG-MAKETOKEN: Position 30, creating token 'END' as ARGS
DEBUG-MAKETOKEN: Before creation - prev_type=<<, curr_type=CMD
DEBUG-MAKETOKEN: Pipeline state - in_pipe=0
DEBUG-MAKETOKEN: Updating prev_type from << to ARGS
DEBUG-MAKETOKEN: prev_type now set to ARGS for next classification
DEBUG-MAKETOKEN: === TOKEN CREATION END ===

DEBUG-TOKENIZE-LOOP: Token 2: extracting 'END' from position 7-9
DEBUG-TOKEN: Adding null token safety stop
DEBUG-TOKEN: Null token added at the end of list
= TOKEN LIST =
[0] CMD [cat]
[1] << [<<]
[2] ARGS [END]
[3] ARGS []

DEBUG-LIST: = LINKED LIST =
DEBUG-LIST: [0] DEBUG-NODE[LIST@linked_list]: Type=CMD, Args=['cat'], Connections: left=(nil), right=(nil), redir=(nil), prev=(nil), next=0x5acccd9e3d90
DEBUG-LIST: [1] DEBUG-NODE[LIST@linked_list]: Type=<<, Args=['<<'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3de0, next=0x5acccd9e3d40
DEBUG-LIST: [2] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=['END'], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d90, next=0x5acccd9c7940
DEBUG-LIST: [3] DEBUG-NODE[LIST@linked_list]: Type=ARGS, Args=[''], Connections: left=(nil), right=(nil), redir=(nil), prev=0x5acccd9e3d40, next=(nil)
DEBUG-LIST: = END LINKED LIST (4 nodes) =
REDIR-DBG: Resetting redirection tracking state
DEBUG-FIX-REDIR: Starting to link redirections for command 'cat'
DEBUG-FIX-REDIR: Found redirection << '<<' for command 'cat'
DEBUG-FIX-REDIR: Set first redirection for command 'cat'
DEBUG-FIX-REDIR: Final redirection chain for cmd 'cat':
  0: << '<<' -> END
DEBUG-VALIDATE-REDIR: Checking redirection node type=<<
DEBUG-VALIDATE-REDIR: Valid redirection node << with embedded filename '<<'
DEBUG-MATCH-CMD: Starting command-argument matching
DEBUG-MATCH-CMD: Found command node 'cat'
DEBUG-MATCH-CMD: Checking if 'END' should be appended to 'cat'
DEBUG-IS-REDIR-TARGET: Checking node 'END', prev=<<
DEBUG-IS-REDIR-TARGET: Found redirection '<<' type=<<
DEBUG-HEREDOC-TARGET: Found heredoc, next=0x5acccd9e3d40, node=0x5acccd9e3d40
DEBUG-HEREDOC-TARGET: Node directly follows heredoc operator
DEBUG-HEREDOC-TARGET: Node IS a heredoc delimiter target
DEBUG-MATCH-CMD: Decision: SKIP
DEBUG-MATCH-CMD: Skipping 'END' (redirection target)
DEBUG-MATCH-CMD: Finished command-argument matching
=== ABSTRACT SYNTAX TREE ===
<< [<<]
├─(redir)-> CMD [cat]
├─(redir)->  [CYCLE DETECTED]
├─(left)->   CMD [cat]
  ├─(redir)->  [CYCLE DETECTED]
DEBUG-AST: = DETAILED AST =
DEBUG-AST: Node(0x5acccd9e3d90): Type=<<, Args=['<<'], Connections: { left->0x5acccd9e3de0 redir->0x5acccd9e3de0 prev->0x5acccd9e3de0 next->0x5acccd9e3d40 }
DEBUG-AST: Node(0x5acccd9e3de0): Type=CMD, Args=['cat'], Connections: { redir->0x5acccd9e3d90 next->0x5acccd9e3d90 }
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3de0)
DEBUG-AST: [CYCLE DETECTED] Node(0x5acccd9e3d90)
DEBUG-EXEC-REDIR: Starting redirection execution for node type=<<
DEBUG-EXEC-REDIR: Found command node: 'cat' (pipeline_context=0)
DEBUG-EXEC-REDIR: Saved stdin=3, stdout=4
DEBUG-EXEC-REDIR: About to process redirection chain
DEBUG-FIX-CHAIN: Starting redirection chain processing
DEBUG-FIX-CHAIN: Start node: << '<<'
DEBUG-FIX-CHAIN: Command: 'cat'
DEBUG-FIX-CHAIN: Processing redirection << '<<'
DEBUG-FIX-CHAIN: Before stripping quotes: '<<'
DEBUG-FIX-CHAIN: After stripping quotes: '<<'
DEBUG: SIGINT received

bleshell$> DEBUG-FIX-CHAIN: Moving to next redirection: END
DEBUG-FIX-CHAIN: Chain processing completed successfully
DEBUG-EXEC-REDIR: Redirection successful, executing command 'cat'
DEBUG-EXEC-REDIR: Command execution completed with result=0
bleshell$> 
